#!/usr/bin/env python3
"""
Organizze to Beancount Importer v1
Converts Organizze Excel exports to Beancount format.
"""

import hashlib
import os
import re
import sys
from datetime import datetime, timedelta
from pathlib import Path

import pandas as pd


def sanitize_name(name: str) -> str:
    """Remove special characters and convert to CamelCase for Beancount."""
    if pd.isna(name):
        return "Unknown"

    name = str(name).strip()

    accented = "áàâãéèêíïóôõúüñçÁÀÂÃÉÈÊÍÏÓÔÕÚÜÑÇ"
    plain = "aaaaeeeiiooouuncAAAAEEIIIOOOUU"
    for a, p in zip(accented, plain):
        name = name.replace(a, p)

    name = re.sub(r"[^a-zA-Z0-9\s]", "", name)

    words = name.split()
    if not words:
        return "Unknown"

    return "".join(word.capitalize() for word in words)


def generate_origin_id(row: pd.Series) -> str:
    """Generate SHA-256 hash for deduplication."""
    desc_col = "Descrição" if "Descrição" in row.index else "Descricao"
    desc = row.get(desc_col, "")
    data = f"{row['Data']}{desc}{row['Valor']}"
    return hashlib.sha256(data.encode()).hexdigest()[:16]


def parse_date(date_val) -> datetime:
    """Parse various date formats from Excel."""
    if isinstance(date_val, datetime):
        return date_val
    if isinstance(date_val, str):
        for fmt in ["%d.%m.%Y", "%d/%m/%Y", "%Y-%m-%d"]:
            try:
                return datetime.strptime(date_val, fmt)
            except ValueError:
                continue
    return pd.to_datetime(date_val)


def load_data(file_path: str) -> pd.DataFrame:
    """Load and preprocess Organizze Excel export."""
    df = pd.read_excel(file_path)

    df.columns = [c.strip() for c in df.columns]

    df["Data"] = df["Data"].apply(parse_date)
    df["Valor"] = pd.to_numeric(df["Valor"], errors="coerce").fillna(0.0)

    df = df.sort_values("Data")

    return df


def discover_accounts(df: pd.DataFrame) -> tuple[list[str], list[str], list[str]]:
    """Discover unique accounts from DataFrame."""
    accounts = set()
    expenses = set()
    incomes = set()

    accounts.add("BancoInter")

    for _, row in df.iterrows():
        category = row.get("Categoria", "")
        if pd.notna(category):
            clean_cat = sanitize_name(category)
            if row["Valor"] < 0:
                expenses.add(clean_cat)
            else:
                incomes.add(clean_cat)

    return sorted(accounts), sorted(expenses), sorted(incomes)


def sanitize_description(desc: str) -> str:
    """Remove or escape problematic characters from description."""
    if pd.isna(desc):
        return "Sem descricao"
    desc = str(desc).strip()
    desc = desc.replace('"', "'")
    desc = desc.replace("\n", " ").replace("\r", " ")
    if len(desc) > 60:
        desc = desc[:57] + "..."
    return desc


def generate_accounts_file(
    accounts: list[str],
    expenses: list[str],
    incomes: list[str],
    first_date: datetime,
    output_path: str,
):
    """Generate accounts.beancount with Open directives."""
    open_date = (first_date - timedelta(days=1)).strftime("%Y-%m-%d")

    lines = [
        "; Accounts Beancount - Auto-generated by organizze_v1.py",
        "; DO NOT EDIT MANUALLY",
        "",
    ]

    lines.append(f"; Assets (Contas bancárias)")
    for acc in accounts:
        lines.append(f'2024-01-01 open Assets:BR:{acc} BRL "STRICT"')

    lines.append("")
    lines.append(f"; Expenses (Categorias de despesa)")
    for exp in expenses:
        lines.append(f'2024-01-01 open Expenses:{exp} BRL "STRICT"')

    lines.append("")
    lines.append(f"; Income (Categorias de receita)")
    for inc in incomes:
        lines.append(f'2024-01-01 open Income:{inc} BRL "STRICT"')

    lines.append("")
    lines.append(f"; Liabilities (Cartões de crédito)")
    lines.append(f"; Adicionar cartões manualmente conforme necessidade")

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    print(f"Generated: {output_path}")


def generate_history_file(df: pd.DataFrame, output_path: str):
    """Generate history.beancount with transactions."""
    lines = [
        "; History Beancount - Auto-generated by organizze_v1.py",
        "; DO NOT EDIT MANUALLY",
        "",
    ]

    desc_col = "Descrição" if "Descrição" in df.columns else "Descricao"
    cat_col = "Categoria" if "Categoria" in df.columns else "Categoria"
    status_col = "Situação" if "Situação" in df.columns else "Situacao"

    grouped_transfers = {}
    regular_entries = []

    for idx, row in df.iterrows():
        date = row["Data"].strftime("%Y-%m-%d")
        desc = sanitize_description(row.get(desc_col, ""))
        category = row.get(cat_col, "")
        value = row["Valor"]
        status = row.get(status_col, "Pago")
        origin_id = generate_origin_id(row)

        flag = "*" if status == "Pago" else "!"

        if pd.isna(category):
            category = "SemCategoria"

        cat_clean = sanitize_name(category)

        if (
            "transferência" in cat_clean.lower()
            or "transferencias" in cat_clean.lower()
        ):
            key = (date, desc)
            if key not in grouped_transfers:
                grouped_transfers[key] = {"entries": [], "net": 0}
            grouped_transfers[key]["entries"].append(
                {
                    "date": date,
                    "flag": flag,
                    "desc": desc,
                    "category": cat_clean,
                    "value": value,
                    "origin_id": origin_id,
                }
            )
            grouped_transfers[key]["net"] += value
            continue

        regular_entries.append(
            {
                "date": date,
                "flag": flag,
                "desc": desc,
                "category": cat_clean,
                "value": value,
                "origin_id": origin_id,
            }
        )

    for entries_dict in grouped_transfers.values():
        entries = entries_dict["entries"]
        if len(entries) >= 2:
            credit = sum(e["value"] for e in entries if e["value"] > 0)
            debit = abs(sum(e["value"] for e in entries if e["value"] < 0))

            date = entries[0]["date"]
            desc = entries[0]["desc"]
            flag = entries[0]["flag"]

            lines.append(f'{date} * "{desc}"')
            lines.append(f"  Assets:BR:BancoInter               {credit:.2f} BRL")
            lines.append(f"  Assets:BR:BancoInter               -{debit:.2f} BRL")
            lines.append(f'  origem_id: "{entries[0]["origin_id"]}"')
            lines.append("")
        else:
            for e in entries:
                regular_entries.append(e)

    for entry in regular_entries:
        date = entry["date"]
        flag = entry["flag"]
        desc = entry["desc"]
        category = entry["category"]
        value = entry["value"]
        origin_id = entry["origin_id"]

        abs_value = abs(value)

        if value < 0:
            debit_account = f"Expenses:{category}"
            credit_account = "Assets:BR:BancoInter"
            debit_val = abs_value
            credit_val = -abs_value
        else:
            debit_account = "Assets:BR:BancoInter"
            credit_account = f"Income:{category}"
            debit_val = abs_value
            credit_val = -abs_value

        lines.append(f'{date} {flag} "{desc}"')
        lines.append(f"  {debit_account:40s} {debit_val:>10.2f} BRL")
        lines.append(f"  {credit_account:40s} {credit_val:>10.2f} BRL")
        lines.append(f'  origem_id: "{origin_id}"')
        lines.append("")

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    print(f"Generated: {output_path}")


def main():
    script_dir = Path(__file__).parent
    project_dir = script_dir.parent

    data_dir = project_dir / "data"
    ledger_dir = project_dir / "ledger"

    xlsx_files = list(data_dir.glob("*.xls*"))
    if not xlsx_files:
        print("ERROR: No Excel files found in data/")
        sys.exit(1)

    excel_file = xlsx_files[0]
    print(f"Processing: {excel_file}")

    df = load_data(str(excel_file))
    print(f"Loaded {len(df)} transactions")

    accounts, expenses, incomes = discover_accounts(df)
    print(
        f"Found {len(accounts)} accounts, {len(expenses)} expenses, {len(incomes)} incomes"
    )

    first_date = df["Data"].min()

    accounts_file = ledger_dir / "accounts.beancount"
    generate_accounts_file(accounts, expenses, incomes, first_date, str(accounts_file))

    history_file = ledger_dir / "history.beancount"
    generate_history_file(df, str(history_file))

    print("\nDone! Files generated:")
    print(f"  - {accounts_file}")
    print(f"  - {history_file}")
    print("\nTo validate: bean-check ledger/main.beancount")


if __name__ == "__main__":
    main()
