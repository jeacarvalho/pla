#!/usr/bin/env python3
"""
Organizze to Beancount Importer v3 - OTIMIZADO
"""

import hashlib
import re
from pathlib import Path
from collections import defaultdict

import pandas as pd


ACCOUNTS_TYPE = {
    "BancoInter": "Assets",
    "BbCorrente": "Assets",
    "C6Bank": "Assets",
    "Carteira": "Assets",
    "Caixa": "Assets",
    "BancoDoBrasilPoupanca": "Assets",
    "ItauPersonalite": "Assets",
    "RendaVariavelInter": "Assets",
    "CdbC6": "Assets",
    "CdbInter": "Assets",
    "CdbEFundosDaycoval": "Assets",
    "TesouroDiretoInter": "Assets",
    "TesouroEasyinvest": "Assets",
    "Pagol": "Assets",
    "CartaoDeCreditoInter": "Liabilities",
    "MastercardC6Bank": "Liabilities",
    "Saraiva": "Liabilities",
    "SmilesBbPlatinum": "Liabilities",
    "LatamPass": "Liabilities",
}


def sanitize_name(name):
    if pd.isna(name):
        return "Unknown"
    name = str(name).strip()
    accented = "áàâãéèêíïóôõúüñçÁÀÂÃÉÈÊÍÏÓÔÕÚÜÑÇ"
    plain = "aaaaeeeiiooouuncAAAAEEIIIOOOUU"
    for a, p in zip(accented, plain):
        name = name.replace(a, p)
    name = re.sub(r"[^a-zA-Z0-9\s]", "", name)
    words = name.split()
    return "".join(word.capitalize() for word in words) if words else "Unknown"


def sanitize_description(desc):
    if pd.isna(desc):
        return "Sem descricao"
    desc = str(desc).strip().replace('"', "'").replace("\n", " ").replace("\r", " ")
    return desc[:57] + "..." if len(desc) > 60 else desc


def get_account_path(conta):
    account_type = ACCOUNTS_TYPE.get(conta, "Assets")
    return (
        f"Liabilities:Cartao:{conta}"
        if account_type == "Liabilities"
        else f"Assets:BR:{conta}"
    )


def generate_origin_id(row):
    return hashlib.sha256(
        f"{row['Data']}{row.get('Descrição', '')}{row['Valor']}{row.get('CONTA', '')}".encode()
    ).hexdigest()[:16]


def main():
    project_dir = Path(__file__).parent.parent
    data_dir = project_dir / "data"
    ledger_dir = project_dir / "ledger"

    input_file = data_dir / "unificado_dr_ordenado.xlsx"
    if not input_file.exists():
        print(f"ERROR: {input_file} not found")
        return

    print("=" * 60)
    print("Organizze -> Beancount Importer v3")
    print("=" * 60)

    print("\nCarregando arquivo...")
    df = pd.read_excel(input_file)
    df["Data"] = pd.to_datetime(df["Data"])
    df = df.sort_values(["Data", "Valor", "D/R"]).reset_index(drop=True)

    print(f"Total: {len(df)} lançamentos")

    # Descobrir contas
    bank_accounts, credit_cards, all_expenses, all_incomes = set(), set(), set(), set()
    for _, row in df.iterrows():
        conta = row.get("CONTA")
        if pd.notna(conta):
            acc_type = ACCOUNTS_TYPE.get(conta, "Assets")
            (bank_accounts if acc_type == "Assets" else credit_cards).add(conta)
        category = row.get("Categoria")
        if pd.notna(category):
            clean_cat = sanitize_name(category)
            # Detectar se é receita baseado no nome da categoria
            income_keywords = [
                "renda",
                "salário",
                "juros",
                "recebimento",
                "depósito",
                "depósito identificado",
                "transferência recebida",
            ]
            is_income = any(kw in clean_cat.lower() for kw in income_keywords)
            (all_incomes if is_income else all_expenses).add(clean_cat)

    print(f"Contas: {len(bank_accounts)} bancárias, {len(credit_cards)} cartões")

    # Gerar accounts.beancount
    lines = [
        "; Accounts Beancount - Auto-generated by organizze_v3.py",
        "; DO NOT EDIT MANUALLY",
        "",
        '2018-01-01 open Equity:SaldoInicial BRL "STRICT"',
        "",
    ]
    for acc in sorted(bank_accounts):
        lines.append(f'2018-01-01 open Assets:BR:{acc} BRL "STRICT"')
    lines.append("")
    for acc in sorted(credit_cards):
        lines.append(f'2018-01-01 open Liabilities:Cartao:{acc} BRL "STRICT"')
    lines.append("")
    for exp in sorted(all_expenses):
        lines.append(f'2018-01-01 open Expenses:{exp} BRL "STRICT"')
    lines.append("")
    for inc in sorted(all_incomes):
        lines.append(f'2018-01-01 open Income:{inc} BRL "STRICT"')

    with open(ledger_dir / "accounts.beancount", "w") as f:
        f.write("\n".join(lines))

    # Processar transações - OTIMIZADO
    print("\nProcessando...")

    # Agrupar por (data, valor) para encontrar pares
    groups = defaultdict(list)
    for idx, row in df.iterrows():
        key = (row["Data"], row["Valor"])
        groups[key].append(idx)

    # Marcar pares de transferências
    paired = set()
    transfer_pairs = []

    for (date, valor), indices in groups.items():
        if len(indices) != 2:
            continue
        i, j = indices

        row1 = df.iloc[i]
        row2 = df.iloc[j]

        # Normalizar descrições para pairing
        def normalize(s):
            s = str(s).lower()
            accented = "áàâãéèêíïóôõúüñç"
            plain = "aaaaeeeiiooouunc"
            for a, p in zip(accented, plain):
                s = s.replace(a, p)
            return s

        desc1 = normalize(row1.get("Descrição", ""))
        desc2 = normalize(row2.get("Descrição", ""))

        # Só parear se ambas tiverem "transfer", "pix", "pagto cartao" ou "boleto"
        transfer_keywords = ["transfer", "pix", "pagto cartao", "boleto"]
        has_transfer_keyword = lambda d: any(kw in d for kw in transfer_keywords)

        if not (has_transfer_keyword(desc1) and has_transfer_keyword(desc2)):
            continue

        # Verificar D/R oposto e contas diferentes
        if row1["D/R"] != row2["D/R"] and row1.get("CONTA") != row2.get("CONTA"):
            paired.add(i)
            paired.add(j)
            transfer_pairs.append((i, j, row1, row2))

    print(f"Transferências pareadas: {len(transfer_pairs)}")
    regular_count = 0

    # Gerar history.beancount
    lines = [
        "; History Beancount - Auto-generated by organizze_v3.py",
        "; DO NOT EDIT MANUALLY",
        "",
    ]

    # Adicionar transferências pareadas
    for i, j, row1, row2 in transfer_pairs:
        date = row1["Data"].strftime("%Y-%m-%d")
        desc = sanitize_description(row1.get("Descrição", ""))
        value = row1["Valor"]

        # D = negativo = dinheiro SAIU (origem)
        # R = positivo = dinheiro ENTROU (destino)
        # Transferência: da conta com D (saída) para conta com R (entrada)
        if row1["D/R"] == "D":
            # row1 = D (origem/saída), row2 = R (destino/entrada)
            from_acc = get_account_path(row1.get("CONTA"))
            to_acc = get_account_path(row2.get("CONTA"))
            from_value = -value  # negativo = crédito (saída)
            to_value = value  # positivo = débito (entrada)
        else:
            # row1 = R (destino/entrada), row2 = D (origem/saída)
            from_acc = get_account_path(row2.get("CONTA"))
            to_acc = get_account_path(row1.get("CONTA"))
            from_value = -value  # negativo = crédito (saída)
            to_value = value  # positivo = débito (entrada)

        lines.append(f'{date} * "{desc}"')
        lines.append(f"  {from_acc:40s} {from_value:>10.2f} BRL")
        lines.append(f"  {to_acc:40s} {to_value:>10.2f} BRL")
        lines.append('  origem_id: "transfer_pair"')
        lines.append("")

    # Adicionar lançamentos regulares
    for idx, row in df.iterrows():
        if idx in paired:
            continue

        date = row["Data"].strftime("%Y-%m-%d")
        desc = sanitize_description(row.get("Descrição", ""))
        category = sanitize_name(row.get("Categoria", "SemCategoria"))
        value = row["Valor"]
        conta = row.get("CONTA", "")
        status = row.get("Situação", "Pago")
        account_type = ACCOUNTS_TYPE.get(conta, "Assets")
        flag = "*" if status == "Pago" else "!"

        desc_lower = desc.lower()

        # Normalizar descrição para comparação (remover acentos)
        desc_normalized = desc_lower
        accented = "áàâãéèêíïóôõúüñç"
        plain = "aaaaeeeiiooouunc"
        for a, p in zip(accented, plain):
            desc_normalized = desc_normalized.replace(a, p)

        # Verificar se é pagamento de cartão (vários padrões)
        is_pagto_cartao = (
            "pagto cartao" in desc_normalized
            or "pagto credito" in desc_normalized
            or "pagamento da fatura" in desc_lower
            or "pagamento de fatura" in desc_lower
            or ("pagamento" in desc_normalized and "fatura" in desc_normalized)
        )

        # Identificar qual cartão está sendo pago
        cartao_pago = None

        # Primeiro: tentar pela coluna "Cartão de crédito" (funciona para lançamentos mais recentes)
        cartao_col = row.get("Cartão de crédito")
        if pd.notna(cartao_col) and str(cartao_col).strip():
            cartao_pago = sanitize_name(cartao_col)
            if cartao_pago == "Nan" or cartao_pago == "Unknown":
                cartao_pago = None

        # Segundo: se não encontrou, tentar detectar pela descrição
        if not cartao_pago and is_pagto_cartao:
            # Normalizar description para matching (sem espaços)
            desc_no_space = desc_normalized.replace(" ", "")

            for cartao in credit_cards:
                # Tentar múltiplos padrões de matching
                cartao_lower = cartao.lower()
                cartao_no_space = cartao_lower.replace(" ", "")

                if (
                    cartao_lower in desc_normalized
                    or cartao_no_space in desc_no_space
                    or cartao_lower.replace("decredito", "") in desc_normalized
                ):
                    cartao_pago = cartao
                    break

            # Se ainda não encontrou, usar heurísticas
            if not cartao_pago:
                if "saraiva" in desc_normalized:
                    cartao_pago = "Saraiva"
                elif "inter" in desc_normalized:
                    cartao_pago = "CartaoDeCreditoInter"
                elif "mastercard" in desc_normalized or "c6" in desc_normalized:
                    cartao_pago = "MastercardC6Bank"
                elif "smiles" in desc_normalized or (
                    "bb" in desc_normalized and "platinum" in desc_normalized
                ):
                    cartao_pago = "SmilesBbPlatinum"
                elif "latam" in desc_normalized:
                    cartao_pago = "LatamPass"

        # Se ainda não encontrou o cartão, usar mapeamento por conta pagadora
        if is_pagto_cartao and not cartao_pago:
            conta_pagadora = row.get("CONTA", "")
            mapeamento_cartao = {
                "BancoInter": "CartaoDeCreditoInter",
                "C6Bank": "MastercardC6Bank",
                "ItauPersonalite": "LatamPass",
                "BbCorrente": "Saraiva",  # Default para BB, pode ajustar depois
            }
            cartao_pago = mapeamento_cartao.get(conta_pagadora)

        # Lógica de geração de lançamentos
        # Baseado na CATEGORIA: se contém palavras de receita = Income, senão = Expenses
        # O valor original (com sinal) determina se é D ou R na conta

        debit = None
        credit = None

        # Lógica de geração de lançamentos
        # D = valor negativo (saída), R = valor positivo (entrada)
        # No Beancount: Asset+ = entrada, Asset- = saída
        # Income- = receita, Expense+ = despesa

        debit = None
        credit = None

        # Detectar se é receita (Income) baseado na categoria
        income_keywords = [
            "renda",
            "salário",
            "juros",
            "recebimento",
            "depósito",
            "depósito identificado",
            "transferência recebida",
            "outras receitas",
        ]
        is_income = any(kw in category.lower() for kw in income_keywords)

        # Detectar saldo inicial - usar Equity:SaldoInicial
        is_saldo_inicial = "saldo inicial" in desc.lower()

        if is_pagto_cartao and cartao_pago:
            # Transferência: Banco -> Cartão (reduzindo passivo)
            # Pagamento de cartão:
            # - Liabilities decreases (debit) = positive in Beancount
            # - Assets decreases (credit) = negative in Beancount
            debit = f"Liabilities:Cartao:{cartao_pago}"
            credit = get_account_path(conta)
            debit_value = value  # positivo = reduzir dívida (débito)
            credit_value = -value  # negativo = dinheiro saiu (crédito)
        elif is_saldo_inicial:
            # Saldo inicial: Equity -> Asset (entrada) ou Asset -> Equity (saída)
            if row["D/R"] == "R":
                # Positivo = entrada de saldo inicial
                debit = get_account_path(conta)
                credit = "Equity:SaldoInicial"
                debit_value = value
                credit_value = -value
            else:
                # Negativo = saída de saldo (estorno)
                debit = "Equity:SaldoInicial"
                credit = get_account_path(conta)
                debit_value = value
                credit_value = -value
        elif is_income:
            # Receita
            if row["D/R"] == "R":
                # Positivo = dinheiro entrou na conta = receita
                # Asset + (entrada), Income - (crédito)
                debit = get_account_path(conta)
                credit = f"Income:{category}"
                debit_value = value
                credit_value = -value
            else:
                # Negativo = dinheiro saiu da conta (estorno de receita)
                # Income + (estorno), Asset - (saída)
                debit = f"Income:{category}"
                credit = get_account_path(conta)
                debit_value = value
                credit_value = -value
        else:
            # Despesa
            if row["D/R"] == "D":
                # Negativo = dinheiro saiu = despesa
                # Expense + (débito), Asset - (crédito)
                debit = f"Expenses:{category}"
                credit = get_account_path(conta)
                debit_value = value
                credit_value = -value
            else:
                # Positivo = dinheiro entrou = estorno de despesa
                # Asset + (entrada), Expense - (estorno)
                debit = get_account_path(conta)
                credit = f"Expenses:{category}"
                debit_value = value
                credit_value = -value

        lines.append(f'{date} {flag} "{desc}"')
        lines.append(f"  {debit:40s} {debit_value:>10.2f} BRL")
        lines.append(f"  {credit:40s} {credit_value:>10.2f} BRL")
        lines.append(f'  origem_id: "{generate_origin_id(row)}"')
        lines.append("")
        regular_count += 1

    print(f"Lançamentos regulares: {regular_count}")

    with open(ledger_dir / "history.beancount", "w") as f:
        f.write("\n".join(lines))

    print("\n" + "=" * 60)
    print("Done! Run: bean-check ledger/main.beancount")
    print("=" * 60)


if __name__ == "__main__":
    main()
