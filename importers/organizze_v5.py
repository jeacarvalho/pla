#!/usr/bin/env python3
"""
Organizze to Beancount Importer v5

Orquestrador que coordena os handlers especializados.

Regras de importação:
a) Despesa: D sem R pareado → Expense+ / Asset-
b) Receita: R sem D pareado → Asset+ / Income-
c) Transferência: D + R pareado por valor (±1 dia) → Asset- / Asset+
d) Pagamento cartão: D com Categoria="Outros" + descrição com "pagamento/fatura" → Liabilities:+ / Asset:-
"""

import logging
from pathlib import Path

import pandas as pd

import card_payments_handler
import expenses_handler
import incomes_handler
import transfers_handler
from organizze_shared import (
    extract_accounts_from_df,
    extract_categories_from_df,
    sanitize_description,
    sanitize_name,
)


logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
logger = logging.getLogger(__name__)


def generate_accounts_file(
    bank_accounts: set,
    credit_cards: set,
    expense_categories: set,
    income_categories: set,
    ledger_dir: Path,
    accounts_with_transactions: set,
    conta_beancount_accounts: set | None = None,
) -> None:
    """Gera arquivo de contas Beancount."""
    if conta_beancount_accounts is None:
        conta_beancount_accounts = set()

    expense_categories = expense_categories | {"SaquesATM", "Boletos", "OutrosCartao"}
    income_categories = income_categories | {"TransferenciasRecebidas"}

    OPEN_DATE = "2024-12-31"

    lines = [
        "; Accounts Beancount - Auto-generated by organizze_v5.py",
        "; DO NOT EDIT MANUALLY",
        "",
        f'{OPEN_DATE} open Equity:SaldoInicial BRL "STRICT"',
        f'{OPEN_DATE} open Equity:TransferenciasPendentes BRL "STRICT"',
        f'{OPEN_DATE} open Equity:Ajustes BRL "STRICT"',
        "",
    ]

    # Bank accounts and credit cards now come from conta_beancount column
    # Not generating automatically anymore

    for exp in sorted(expense_categories):
        lines.append(f'{OPEN_DATE} open Expenses:{exp} BRL "STRICT"')
    lines.append("")
    for inc in sorted(income_categories):
        lines.append(f'{OPEN_DATE} open Income:{inc} BRL "STRICT"')

    expense_categories_full = {f"Expenses:{c}" for c in expense_categories}
    income_categories_full = {f"Income:{c}" for c in income_categories}
    existing_accounts = expense_categories_full | income_categories_full

    if conta_beancount_accounts:
        lines.append("")
        lines.append("; Custom accounts from conta_beancount column")
        for acc in sorted(conta_beancount_accounts):
            acc_clean = acc.strip()
            if acc_clean not in existing_accounts:
                lines.append(f'{OPEN_DATE} open {acc_clean} BRL "STRICT"')

    with open(ledger_dir / "accounts.beancount", "w") as f:
        f.write("\n".join(lines))


def generate_saldo_inicial_entries(df: pd.DataFrame) -> tuple[list[str], int]:
    """Gera entradas para saldos iniciais."""
    lines = []
    count = 0

    for idx, row in df.iterrows():
        if row["D/R"] != "D":
            continue

        desc = sanitize_description(row.get("Descrição", ""))
        if "saldo inicial" not in desc.lower():
            continue

        date = row["Data"].strftime("%Y-%m-%d")
        value = abs(row["Valor"])
        conta = row.get("CONTA", "")
        status = row.get("Situação", "Pago")
        flag = "*" if status == "Pago" else "!"

        from organizze_shared import get_account_path

        debit = get_account_path(conta)

        lines.append(f'{date} {flag} "{desc}"')
        lines.append(f"  {debit:40s} {value:>10.2f} BRL")
        lines.append(f"  Equity:SaldoInicial {-value:>10.2f} BRL")
        lines.append('  origem_id: "saldo_inicial"')
        lines.append("")
        count += 1

    return lines, count


def main():
    project_dir = Path(__file__).parent.parent
    data_dir = project_dir / "data"
    ledger_dir = project_dir / "ledger"

    input_file = data_dir / "unificado_dr_ordenado.xlsx"
    if not input_file.exists():
        logger.error(f"Arquivo não encontrado: {input_file}")
        return

    logger.info("Iniciando importação Organizze -> Beancount v5")

    df = pd.read_excel(input_file)
    df["Data"] = pd.to_datetime(df["Data"])
    df = df.sort_values(["Data", "Valor"]).reset_index(drop=True)

    logger.info(f"Total de lançamentos: {len(df)}")

    bank_accounts, credit_cards = extract_accounts_from_df(df)
    logger.info(f"Contas: {len(bank_accounts)} bancárias, {len(credit_cards)} cartões")

    # 1. Primeiro: identificar pagamentos de cartão (para isolar primeiro)
    pagto_cartao_indices = card_payments_handler.identify_card_payment_indices(df)

    # 2. Segundo: identificar transferências (deve rodar antes de receita/despesa)
    processed_transfers, transfer_orphans = transfers_handler.identify_transfers(
        df, pagto_cartao_indices
    )

    # Usar índices de transferência E órfãos como exclusão base
    orphan_indices = {o["idx"] for o in transfer_orphans}
    excluded_indices = pagto_cartao_indices | processed_transfers | orphan_indices

    # 3. Terceiro: identificar outros casos especiais
    cartao_expense_indices = expenses_handler.identify_cartao_expense_indices(df)
    boleto_indices = expenses_handler.identify_boleto_indices(df)

    # Adicionar aos excluídos
    excluded_indices |= cartao_expense_indices | boleto_indices

    expense_categories, income_categories = extract_categories_from_df(df)

    accounts_with_transactions = set(df["CONTA"].dropna().unique())

    conta_beancount_accounts = set()
    for val in df["conta_beancount"].dropna().unique():
        if val and str(val).strip():
            conta_beancount_accounts.add(str(val).strip())

    generate_accounts_file(
        bank_accounts,
        credit_cards,
        expense_categories,
        income_categories,
        ledger_dir,
        accounts_with_transactions,
        conta_beancount_accounts,
    )

    logger.info("Gerando lançamentos...")

    lines = [
        "; History Beancount - Auto-generated by organizze_v5.py",
        "; DO NOT EDIT MANUALLY",
        "",
    ]

    total_count = 0

    transfer_lines, transfer_count = transfers_handler.generate_transfer_entries(
        df, processed_transfers
    )
    lines.extend(transfer_lines)
    total_count += transfer_count

    orphan_lines, orphan_count = transfers_handler.generate_orphan_transfer_entries(
        transfer_orphans, df
    )
    lines.extend(orphan_lines)
    total_count += orphan_count

    pagto_lines, pagto_count = card_payments_handler.generate_card_payment_entries(
        df, pagto_cartao_indices
    )
    lines.extend(pagto_lines)
    total_count += pagto_count

    cartao_expense_lines, cartao_expense_count = (
        expenses_handler.generate_cartao_expense_entries(df, cartao_expense_indices)
    )
    lines.extend(cartao_expense_lines)
    total_count += cartao_expense_count

    boleto_lines, boleto_count = expenses_handler.generate_boleto_entries(
        df, boleto_indices
    )
    lines.extend(boleto_lines)
    total_count += boleto_count

    # Transferências e saldos iniciais/ajustes agora são tratados pelo transfers_handler
    # Não precisa mais chamar incomes_handler para esses casos

    expense_lines, expense_count = expenses_handler.generate_expense_entries(
        df, excluded_indices
    )
    lines.extend(expense_lines)
    total_count += expense_count

    income_lines, income_count = incomes_handler.generate_income_entries(
        df, excluded_indices
    )
    lines.extend(income_lines)
    total_count += income_count

    with open(ledger_dir / "history.beancount", "w") as f:
        f.write("\n".join(lines))

    logger.info(f"Total de lançamentos: {total_count}")
    logger.info("Concluído! Execute: bean-check ledger/main.beancount")


if __name__ == "__main__":
    main()
